package main

import (
    "net/http"
    "strings"
    "time"
    "github.com/stretchr/testify/assert"

    "github.com/gin-gonic/gin"
    "gorm.io/gorm"
    "gorm.io/driver/postgres"
    "github.com/golang-jwt/jwt/v5"
)


type album struct {
    ID     string  `json:"id"`
    Title  string  `json:"title"`
    Artist string  `json:"artist"`
    Price  float64 `json:"price"`
}


var albums = []album{
    {ID: "1", Title: "Blue Train", Artist: "John Coltrane", Price: 56.99},
    {ID: "2", Title: "Jeru", Artist: "Gerry Mulligan", Price: 17.99},
    {ID: "3", Title: "Sarah Vaughan and Clifford Brown", Artist: "Sarah Vaughan", Price: 39.99},
}

var db *gorm.DB // Make db a package-level variable

var jwtSecret = []byte("your-secret-key") // In production, use environment variable

// JWT Claims structure
type Claims struct {
    UserID string `json:"user_id"`
    jwt.RegisteredClaims
}

// Middleware to authenticate JWT tokens
func authMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
            c.Abort()
            return
        }

        // Extract token from "Bearer <token>"
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")
        if tokenString == authHeader {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token format"})
            c.Abort()
            return
        }

        // Parse and validate token
        token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
            return jwtSecret, nil
        })

        if err != nil || !token.Valid {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
            c.Abort()
            return
        }

        // Add user info to context
        if claims, ok := token.Claims.(*Claims); ok {
            c.Set("user_id", claims.UserID)
        }

        c.Next()
    }
}

//Test
func TestGrpcServerResponse(t *testing.T) {
    //Create a client for the endpoint/start the server
    go startServer()

    // Perform an HTTP request to the endpoint
    resp, err := http.Get("http://localhost:8080/api/endpoint")

    //Add assertions to verify the response
    assert.NoError(t, err)
    assert.Equal(t, http.StatusOK, resp.StatusCode)
}

// Login endpoint to get JWT token
func login(c *gin.Context) {
    var loginData struct {
        Username string `json:"username"`
        Password string `json:"password"`
    }

    if err := c.BindJSON(&loginData); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
        return
    }

    // Simple authentication (in production, check against database)
    if loginData.Username == "admin" && loginData.Password == "password" {
        // Create JWT token
        claims := &Claims{
            UserID: loginData.Username,
            RegisteredClaims: jwt.RegisteredClaims{
                ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
                IssuedAt:  jwt.NewNumericDate(time.Now()),
            },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString(jwtSecret)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not create token"})
            return
        }

        c.JSON(http.StatusOK, gin.H{"token": tokenString})
    } else {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
    }
}

func main() {
    // Initialize database
    var err error
    db, err = gorm.Open(postgres.Open("host=localhost user=postgres password=postgres dbname=postgres port=5433 sslmode=disable"), &gorm.Config{})
    if err != nil {
        panic("failed to connect database")
    }
    db.AutoMigrate(&album{})
    db.Create(&album{ID: "1", Title: "Blue Train", Artist: "John Coltrane", Price: 56.99})

    // Initialize router
    router := gin.Default()
    
    // Public routes (no authentication required)
    router.POST("/login", login)
    router.GET("/albums", getAlbums)
    router.GET("/albums/:id", getAlbumByID)
    
    // Protected routes (authentication required)
    protected := router.Group("/")
    protected.Use(authMiddleware())
    {
        protected.POST("/albums", postAlbums)
        protected.PUT("/albums/:id", updateAlbumByID)
        protected.DELETE("/albums/:id", deleteAlbumByID)
    }

    router.Run(":8080")
}


func getAlbums(c *gin.Context) {
    var dbAlbums []album
    if err := db.Find(&dbAlbums).Error; err != nil {
        c.IndentedJSON(http.StatusInternalServerError, gin.H{"message": "could not fetch albums"})
        return
    }
    c.IndentedJSON(http.StatusOK, dbAlbums)
}


func postAlbums(c *gin.Context) {
    var newAlbum album

    if err := c.BindJSON(&newAlbum); err != nil {
        c.IndentedJSON(http.StatusBadRequest, gin.H{"message": "invalid request"})
        return
    }

    // Save to the database
    if err := db.Create(&newAlbum).Error; err != nil {
        c.IndentedJSON(http.StatusInternalServerError, gin.H{"message": "could not create album"})
        return
    }

    c.IndentedJSON(http.StatusCreated, newAlbum)
}

func getAlbumByID(c *gin.Context) {
    id := c.Param("id")

    var a album
    if err := db.First(&a, "id = ?", id).Error; err != nil {
        c.IndentedJSON(http.StatusNotFound, gin.H{"message": "album not found"})
        return
    }
    c.IndentedJSON(http.StatusOK, a)
}

func updateAlbumByID(c *gin.Context) {
    id := c.Param("id")
    var updatedAlbum album

    if err := c.BindJSON(&updatedAlbum); err != nil {
        c.IndentedJSON(http.StatusBadRequest, gin.H{"message": "invalid request"})
        return
    }

    var existingAlbum album
    if err := db.First(&existingAlbum, "id = ?", id).Error; err != nil {
        c.IndentedJSON(http.StatusNotFound, gin.H{"message": "album not found"})
        return
    }

    // Update fields
    existingAlbum.Title = updatedAlbum.Title
    existingAlbum.Artist = updatedAlbum.Artist
    existingAlbum.Price = updatedAlbum.Price

    db.Save(&existingAlbum)
    c.IndentedJSON(http.StatusOK, existingAlbum)
}

func deleteAlbumByID(c *gin.Context) {
    id := c.Param("id")
    var album album

    // Check if the album exists
    if err := db.First(&album, "id = ?", id).Error; err != nil {
        c.IndentedJSON(http.StatusNotFound, gin.H{"message": "album not found"})
        return
    }

    // Delete the album
    if err := db.Delete(&album).Error; err != nil {
        c.IndentedJSON(http.StatusInternalServerError, gin.H{"message": "could not delete album"})
        return
    }

    c.IndentedJSON(http.StatusOK, gin.H{"message": "album deleted"})
}
